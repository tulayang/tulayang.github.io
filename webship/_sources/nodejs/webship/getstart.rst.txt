快速开始
===============================

webship 是一个 node web 应用程序框架，专注于效率和快速开发，包含许多独立的小的子模块。

安装
-------------------------------

webship 需要 node v8.9.4 或者更高版本的支持。安装：

.. container:: coder

  .. code-block:: sh
   
    $ npm install webship

Hello World
-------------------------------

编写 webship 应用程序非常简单：

.. container:: coder

  .. code-block:: js

    import * as Http from 'http'                      // 导入 node http 模块
    import * as Webship from 'webship'                // 导入 webship 模块

    const disp = Webship.createDispatcher({           // 创建调度器
      formUploadDir: '/tmp'                           // 配置一个目录，用于保存上传的文件
    })         
    const router = Webship.createRouter()             // 创建路由器

    disp.addRouter(router)                            // 把路由器添加到调度器
    Http.createServer(disp.callback()).listen(10001)  // 创建服务器，监听 10001 端口。把调度器绑定到服务器，接管 HTTP 请求响应操作

    router.get('/', (req, res) => {                   // 注册路由函数，处理 HTTP 请求
      res.body = 'Hello World'
    })

一旦 webship 的调度器绑定到服务器后，所有的 HTTP 请求操作都会通过 webship 调度器完成。之后，你只需要创建路由器，把路由器添加到调度器，然后专心编写路由函数。

整个过程描述：

1. 创建调度器
2. 创建服务器
3. 把调度器绑定到服务器
4. 创建路由器
5. 编写路由器的注册函数，处理 HTTP 请求
6. 重复第 5 步

操作序列
-------------------------------

webship 允许同一个请求路径注册多个操作：

.. container:: coder

  .. code-block:: js

    router.get('/', (req, res) => {
      console.log('记录一条日志')
    })

    router.get('/', (req, res) => {
      res.body = 'Hello World'
    })

你可以使用序列的方式串联：

.. container:: coder  
 
  .. code-block:: js

    function logging(req, res) => {
      console.log('记录一条日志')
    })

    function respond(req, res) {
      res.body = 'Hello World'
    }

    router.get('/', logging, respond)

请求方法
-------------------------------

注册路由函数时，需要指定请求方法。webship 处理标准 HTTP 操作，支持标准的 HTTP 请求方法。当前至少支持：

.. table:: 

  =============  ============================
  HTTP 请求方法   路由注册
  =============  ============================
  ``GET``        ``router.get(path, cb)``
  ``POST``       ``router.post(path, cb)``
  ``PUT``        ``router.put(path, cb)``
  ``DELETE``     ``router.delete(path, cb)``
  ``HEAD``       ``router.head(path, cb)``
  ``OPTIONS``    ``router.optons(path, cb)``  
  =============  ============================

你可以注册对应不同 HTTP 方法的路由函数：

.. container:: coder  
 
  .. code-block:: js

    router.get('/', (req, res) => {
      // TODO
    })

    router.post('/', (req, res) => {
      // TODO
    })

    router.put('/', (req, res) => {
      // TODO
    })

    router.delete('/', (req, res) => {
      // TODO
    })

请求路径
-------------------------------

注册路由函数时，需要指定请求路径。请求路径是一个（模糊正则表达式的）字符串，比如 ``/:username/blog/:blogId``、``/``、``/news``。带有 ``:`` 的表示是一个变量，在路由函数内部通过 ``req.params`` 可以访问到路径参数 ``params`` --- 保存了替换后的值：

.. container:: coder  
 
  .. code-block:: js

    router.get('/:username/blog/:blogId', (req, res) => {
      console.log(req.params.username)
      console.log(req.params.blogId)
    })

请求操作
-------------------------------

在路由函数内部，通过 ``req.headers`` 可以访问请求头，这是一个 key-value 对象，包含标准 HTTP 请求头。这个对象的 key 都是小写的：

.. container:: coder  
 
  .. code-block:: js

    router.get('/:username/blog/:blogId', (req, res) => {
      console.log(req.headers['content-type'])
      console.log(req.headers['content-length'])
      console.log(req.headers['transfer-encoding'])
    })

在路由函数内部，通过 ``req.body`` 可以访问请求体。根据 ``req.headers`` 请求头中 ``content-type`` 不同，``req.body`` 是不一样的。目前支持以下几种请求体：

.. table:: 

   =====================================  ============================== ==========================
     content-type                         内容格式                         req.body 格式 
   =====================================  ============================== ==========================
   ``application/json``                   JSON 格式                       JSON 对象
   ``application/x-www-form-urlencoded``  表单格式                         JSON 对象
   ``multipart/form-data``                二进制文件                       JSON 对象，里面包含文件对象
   其他                                    其他格式                         字符串
   =====================================  ============================== ==========================

.. container:: coder  
 
  .. code-block:: js

    router.get('/:username/blog/:blogId', (req, res) => {
      console.log(req.headers['content-type'])
      console.log(req.body)
    })

响应操作
-------------------------------

通常，HTTP 响应在路由函数内部完成。

在路由函数内部，函数的第 2 个参数 ``res`` 表示响应对象，你可以通过操作 ``res`` 完成 HTTP 响应。``res.headers=`` 设定响应头，``res.body=`` 设定响应体。

回复一个文本
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

回复客户端 'Hello world' 字符串：

.. container:: coder  
 
  .. code-block:: js

    router.get('/', (req, res) => {
      res.body = 'Hello world'     
    })

回复一个网页
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

你可以回复 HTML 文本 （即网页），这时候需要指定回复内容的媒体格式 （HTTP 规范）：

.. container:: coder  
 
  .. code-block:: js

    router.get('/', (req, res) => {
      res.headers = {
        'content-type': 'text/html'
      }

      res.body = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <title>Hello world</title>
        </head>
        <body>
          <h1>Welcome to webship!</h1>
        </body>
        </html>
      `
    })

你可以通过 ``res.headers`` 指定通用的 HTTP 响应头。

回复一个 JSON
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

你也可以指定 JSON 格式的回复内容：

.. container:: coder  
 
  .. code-block:: js

    router.get('/', (req, res) => {
      res.headers = {
        'content-type': 'application'
      }

      res.body = {
        username: 'xiaoming',
        age: 21
      }
    })

错误处理
-------------------------------

在路由函数内部，有时候，处理的过程中会存在某些错误。使用 ``cond()`` 函数可以帮助你简单快速的中断路由处理、并且回复客户端 HTTP 错误代码和错误消息：

.. container:: coder  
 
  .. code-block:: js

    router.get('/:username', (req, res) => {
      Webship.cond(req.params.username === 'xiaoming', Webship.ErrorCode.FORBIDDEN)
      res.body = 'Hello world' 
    })

上面的路由函数首先检查请求的用户名是不是 ``'xiaoming'``，如果不是的话，就中断处理，并且制造一个 ``Webship.WebshipError`` 错误，回复客户端 ``Webship.ErrorCode.FORBIDDEN`` 对应的 HTTP 错误代码和错误消息。默认情况下，这个错误代码是 ``403``，错误消息是 ``'Forbidden'``。

你也可以不使用 ``cond()``，自己手动抛出错误：

.. container:: coder  
 
  .. code-block:: js

    router.get('/:username', (req, res) => {
      if (req.params.username !== 'xiaoming') {
        throw Webship.createWebshipError(Webship.ErrorCode.FORBIDDEN)
      } 

      res.body = 'Hello world' 
    })

事件
-------------------------------

为了方便自定义行为，webship 提供了 3 个事件，分别是：

.. table:: 

   ==========  ==============================
     事件       描述
   ==========  ==============================
   ``begin``   每当有新的 HTTP 请求时触发
   ``finsih``  每当一个 HTTP 请求处理完成时触发
   ``error``   每当处理 HTTP 请求出现错误时触发
   ==========  ==============================

你可以在需要的时候，编写这些事件的处理函数。比如，``begin`` 触发的时候，记录当前时间；``finish`` 触发的时候，记录当前时间。这样就可以知道这次 HTTP 请求的开始时间和结束时间，并且计算所花费的时间。

.. container:: coder  
 
  .. code-block:: js

    const disp = Webship.createDispatcher({})

    disp.on('begin', (req, res) => {
      console.log('新的请求，开始时间：', Date.now())
    })

    disp.on('finish', (req, res) => {
      console.log('一个请求完成，结束时间：', Date.now())
    })

    disp.on('error', (err) => {
      console.log('一个请求出现错误：', err.message)
    })

环境变量
-------------------------------

webship 提供了环境变量的设定，方便在创建调度器时指定一些变量，在路由处理的时候访问这些变量。例子：

.. container:: coder  
 
  .. code-block:: js

    const disp = Webship.createDispatcher({}, {
      x: 100
    })
    const router = Webship.createRouter()

    disp.addRouter(router)

    router.get('/:username', (req, res, context) => {
      console.log(context.x === 100)
    })

通过这个环境变量，你可以绑定数据库或者其他设施的引用，以方便路由处理的时候访问。

