快速开始
===============================

webship-renderer 是一个 web 渲染服务器，基于 webship framework 构建，提供自动的路由功能。使用 webship-renderer 你不再需要编写 HTTP 服务器，只需要把精力集中于前端 HTML 的开发中。

配合 React 框架，你能快速构建模块的、组件化的、容易管理维护的 HTML 图形界面。如图所示：

.. container:: coder

  .. code:: md

    React Component
    React Component   ==>   window.WEBSHIP_RENDERER_ROUTES {}   ==>   webship-renderer call ReactDOM.render() 
    React Component
    ...

.. warning:: 

  你应该在 JavaScript 程序中（浏览器端）导入 react 和 react-dom 这两个库，webship-renderer 服务器发往前端的 JavaScript 需要这两个库的支持。

安装
-------------------------------

.. container:: coder

  .. code-block:: sh
   
    $ npm install webship-renderer

Hello World
-------------------------------

在这个章节，我们将一步一步介绍如何使用 webship-renderer 快速开发 web 用户界面。

假设我们的应用程序的目录是这样的：

.. container:: coder

  .. code:: md

    app
    ├── node_modules
    │   ├── webship-renderer
    │   └── ...
    ├── src
    │   ├── index.tsx
    │   ├── user.tsx
    │   └── blog.tsx
    ├── dist
    ├── webship-renderer.config.js
    ├── package.json
    └── ...

.. list-table:: 
   :widths: 15 10 
   :header-rows: 1

   * - 文件名
     - 描述
   * - node_modules
     - nodejs 软件库
   * - src
     - 源代码目录
   * - dist
     - 编译后的目标代码目录
   * - webship-renderer.config.js
     - webship-renderer 配置文件
   * - package.json
     - nodejs 配置文件
       
现在，我们打算开发两个页面：**用户页面 user.tsx** 和 **博客页面 blog.tsx** 。此外，我们还需要一个 **index.tsx** 把这些页面配置到 webship-renderer 。

.. note::

  React 使用一种称为 JSX 的语法，提供对 JavaScript 的编译，使你在编写 JavaScript 时可以把 HTML 文本当做对象使用。这种文件的扩展名通常约定为 **.jsx**，通过编译后会生成 **.js** 文件。webship-renderer 使用 TypeScript 的编译器，支持 React JSX 语法编译，所以此处使用 **.tsx** 扩展名，通过编译后生成 **.js** 文件。

1. 编写用户界面 user.tsx
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 **src/user.tsx** 文件中输入以下代码：

.. container:: coder

  .. code:: ts
    
    import * as React from 'react'
    import {Component} from 'react'

    export class User extends Component {
      render() {
        return (
          <div id="user">
            <h1>User {this.props.username}</h1>
          </div>
        )
      }
    }
  
上面编写了一个标准的 React Component，渲染一个 ``HTML div`` 元素，里面的 ``{this.props.username}`` 表明这是一个变量，通过 React Props 获取。

2. 编写博客界面 blog.tsx
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 **src/blog.tsx** 文件中输入以下代码：

.. container:: coder

  .. code:: ts
    
    import * as React from 'react'
    import {Component} from 'react'

    export class Blog extends Component {
      render() {
        return (
          <div id="blog">
            <h1>Blog {this.props.blogId}</h1>
          </div>
        )
      }
    }
  
上面编写了一个标准的 React Component，渲染一个 ``HTML div`` 元素，里面的 ``{this.props.blogId}`` 表明这是一个变量，通过 React Props 获取。

3. 编写注册 index.tsx
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 **src/index.tsx** 文件中输入以下代码：

.. container:: coder

  .. code:: ts
    
    import * as Client from 'webship-renderer/client'
    import * as React from 'react'
    import {User} from './user'
    import {Blog} from './blog'

    Client.get('/:username', (params) => {
      return <User username={params.username}/>
    })

    Client.get('/:username/blog/:blogId', (params) => {
      return <Blog username={params.username} blogId={params.blogId}/>
    })
  
这个文件是程序的主文件（入口文件）。调用 ``webship-renderer/client`` 模块，使用 ``get(path, callback)`` 方法把 ``User`` 和 ``Blog`` 两个页面组件分别注册到不同的路径 path。

当前，``webship-renderer/client`` 只有一个方法 ``get(path, callback)``，它会把 ``路径 path`` 和 ``回调函数 callback`` 绑定到 ``window.WEBSHIP_RENDERER_ROUTES`` 这个全局变量，webship-renderer 服务器会根据这个全局变量进行动态渲染。

``callback`` 的参数 ``params`` 是一个路径协议，根据注册的 ``路径 path`` 的变量，``params`` 会有不同的属性值。比如 ``/:username/blog/:blogId``，``params`` 的结构是 ``{username: string, blogId: string}``。具体的值由用户请求的网络地址而定，比如用户访问 **http://127.0.0.1:10001/xiaoming/blog/100**，那么 ``params`` 的值是 ``{username: 'xiaoming', blogId: '100'}``。

.. note::

  ``params`` 是提供动态数据填充的一个重要技巧，你可以使用这个参数为页面提供动态的数据，比如根据不同的用户名显示不同的用户信息。

4. 配置 webship-renderer.config.js
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

webship-renderer 服务器启动的时候，会查找应用目录的 webship-renderer.config.js 文件，作为服务器的启动配置。在 **webship-renderer.config.js** 文件中输入以下代码：

.. container:: coder

  .. code:: ts

    const Path = require('path')

    module.exports = {
      hostname: '127.0.0.1',
      port: 10001,
      serverName: 'Grass server',
      static: {
        dirname: Path.join(__dirname, './static'), 
        prefix: '/static',
        javascript: [
          '/static/js_modules/react.min.js',
          '/static/js_modules/react-dom.min.js',
          '/static/js/index.js'
        ],
        css: [
          '/static/css/index.css'
        ]
      },
      pathnames: [
        '/:username',
        '/:username/blog/:blogId'
      ] 
    }

.. list-table:: 
   :widths: 20 30 
   :header-rows: 1

   * - 属性
     - 描述
   * - hostname
     - 服务器地址
   * - port
     - 服务器端口号
   * - serverName
     - 服务器启动后，在日志显示的名字
   * - static.dirname
     - 静态文件 （javascript css html htm） 的存放目录 
   * - static.prefix
     - 静态文件的路由前缀，如果不需要设置为 ``''``
   * - static.javascript
     - 在网页导入的 javascript 文件
   * - static.css
     - 在网页导入的 css 文件    
   * - pathnames
     - 为 webship-renderer 服务器注册路由，和 **src/index.tsx** 注册的路由路径相同

4. 启动 webship-renderer 服务器
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在命令行输入以下命令启动 webship-renderer 服务器：

.. container:: coder

  .. code-block:: sh

    $ node_modules/webship-renderer/bin/webship-renderer

你也可以在 **package.json** 加入 ``scripts`` 命令：

.. container:: coder

  .. code-block:: sh

    "scripts": {
      "start": "node_modules/webship-renderer/bin/webship-renderer"
    }

然后，在命令行输入以下命令启动 webship-renderer 服务器：

.. container:: coder

  .. code-block:: sh

    $ npm run start

5. 打开浏览器，访问页面
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

打开你的 Chrome 或者 Firefox 浏览器，输入网址 **http://127.0.0.1:10001/xiaoming** ，你应该能访问到以下内容的页面：

.. container:: img

  .. code-block:: md

    User xiaoming

输入网址 **http://127.0.0.1:10001/xiaoming/blog/100** ，你应该能访问到以下内容的页面：

.. container:: img

  .. code-block:: md

    Blog 100

参考文档
-------------------------------

.. toctree::
  :maxdepth: 1

  ../webship/index